# GolfScript Built-ins
[원본-EN](https://www.golfscript.com/golfscript/builtin.html)

다음은 모든 내장 함수(built-ins)에 대한 상세한 설명과 해당 내장 함수의 다양한 용례에 대한 예시입니다.

이 "함수들"은 실제로는 인자를 받지 않지만, 일반적으로 스택에서 고정된 수의 항목을 꺼내어 사용합니다.
**Coerce**는 두 인자를 동일한 타입으로 강제 변환(coercion)함을 의미하고,
**Order**는 첫 번째 인자의 타입 우선순위가 두 번째 인자보다 낮을 경우, 이 두 인자의 순서를 바꾼다는 것을 의미합니다.

## 목차 (기능별 분류)


### 1. 스택 조작 (Stack Manipulation)
- [`@`](#스택-조작-stack-manipulation) - 스택의 상위 3개 요소 회전
- [`\`](#스택-조작-stack-manipulation) - 스택 상위 두 요소 교환
- [`.`](#스택-조작-stack-manipulation) - 스택 맨 위 요소 복제
- [`$`](#스택-조작-stack-manipulation) - 스택의 n번째 항목 복사
- [`;`](#스택-조작-stack-manipulation) - 스택 맨 위 값 팝하고 버림

### 2. 산술 연산 (Arithmetic Operations)
- [`+`](#산술-연산-arithmetic-operations) - 덧셈, 연결
- [`-`](#산술-연산-arithmetic-operations) - 뺄셈, 차집합
- [`*`](#산술-연산-arithmetic-operations) - 곱셈, 반복, 조인, 폴드
- [`/`](#산술-연산-arithmetic-operations) - 나눗셈, 분할, 그룹화, Each, Unfold
- [`%`](#산술-연산-arithmetic-operations) - 나머지, 필터링, 매핑
- [`?`](#산술-연산-arithmetic-operations) - 거듭제곱, 인덱스 찾기
- [`(`](#산술-연산-arithmetic-operations) - 1 감소, 왼쪽 Uncons
- [`)`](#산술-연산-arithmetic-operations) - 1 증가, 오른쪽 Uncons
- [`abs`](#산술-연산-arithmetic-operations) - 절댓값

### 3. 비트 연산 (Bitwise Operations)
- [`~`](#비트-연산-bitwise-operations) - 비트 반전, 평가, 언팩
- [`|`](#비트-연산-bitwise-operations) - 비트 OR
- [`&`](#비트-연산-bitwise-operations) - 비트 AND, 교집합
- [`^`](#비트-연산-bitwise-operations) - 비트 XOR, 대칭 차집합

### 4. 비교 연산 (Comparison Operations)
- [`<`](#비교-연산-comparison-operations) - 작은지 비교, 슬라이싱 (앞부분)
- [`>`](#비교-연산-comparison-operations) - 큰지 비교, 슬라이싱 (뒷부분)
- [`=`](#비교-연산-comparison-operations) - 같은지 비교, 인덱스 접근
- [`!`](#비교-연산-comparison-operations) - 논리 부정

### 5. 논리 연산 (Logical Operations)
- [`and`](#논리-연산-logical-operations) - 논리 AND (지연 평가)
- [`or`](#논리-연산-logical-operations) - 논리 OR (지연 평가)
- [`xor`](#논리-연산-logical-operations) - 논리 XOR (지연 평가)

### 6. 배열/문자열 조작 (Array/String Manipulation)
- [`,`](#배열문자열-조작-arraystring-manipulation) - 범위 생성, 크기 반환, 필터링
- [`zip`](#배열문자열-조작-arraystring-manipulation) - 행렬 전치
- [`base`](#배열문자열-조작-arraystring-manipulation) - 진법 변환

### 7. 제어 구조 (Control Structures)
- [`if`](#제어-구조-control-structures) - 조건 분기
- [`while`](#제어-구조-control-structures) - 조건 루프
- [`until`](#제어-구조-control-structures) - 조건 루프 (반대)
- [`do`](#제어-구조-control-structures) - do-while 루프

### 8. 변수 및 할당 (Variables and Assignment)
- [`:`](#변수-및-할당-variables-and-assignment) - 변수 할당

### 9. 입출력 (Input/Output)
- [`print`](#입출력-inputoutput) - 출력
- [`puts`](#입출력-inputoutput) - 줄바꿈과 함께 출력
- [`p`](#입출력-inputoutput) - 디버그 출력
- [`n`](#입출력-inputoutput) - 줄바꿈 문자

### 10. 평가 및 문자열 변환 (Evaluation and String Conversion)
- [`~`](#평가-및-문자열-변환-evaluation-and-string-conversion) - 평가, 언팩
- [`` ` ``](#평가-및-문자열-변환-evaluation-and-string-conversion) - 문자열 표현 생성

### 11. 리터럴 및 문법 (Literals and Syntax)
- [`{ }`](#리터럴-및-문법-literals-and-syntax) - 블록 생성
- [`'`](#리터럴-및-문법-literals-and-syntax) - 원시 문자열
- [`"`](#리터럴-및-문법-literals-and-syntax) - 이스케이프 문자열
- [`[ ]`](#리터럴-및-문법-literals-and-syntax) - 배열 생성
- [`#`](#리터럴-및-문법-literals-and-syntax) - 주석

### 12. 기타 유틸리티 (Miscellaneous Utilities)
- [`rand`](#기타-유틸리티-miscellaneous-utilities) - 난수 생성

---

## 스택 조작 (Stack Manipulation)

**`@`**

* **인자 개수:** 3

* **설명:** 스택의 상위 3개 요소를 회전시켜 세 번째 요소가 맨 위로 오게 함 <br/>
  `1 2 3 4 @` → `1 3 4 2`

---

**`\`**

* **인자 개수:** 2

* **설명:** 스택의 상위 두 요소를 교환 <br/>
  `1 2 3 \` → `1 3 2`

---

**`.`**

* **인자 개수:** 1

* **설명:** 스택 맨 위 요소를 복제 <br/>
  `1 2 3.` → `1 2 3 3`

---

**`$`**

* **인자 개수:** 1 또는 2

* **정수에 대해:** 스택의 위에서 n번째 항목을 복사 <br/>
  `1 2 3 4 5  1$` → `1 2 3 4 5 4`

* **배열(문자열 포함)에 대해:** 정렬 수행 <br/>
  `'asdf'$` → `"adfs"`

* **블록에 대해:** 주어진 매핑에 따라 정렬 <br/>
  `[5 4 3 1 2]{-1*}$` → `[5 4 3 2 1]`

---

**`;`**

* **인자 개수:** 1

* **설명:** 스택 맨 위의 값을 팝(pop)하고 버림 <br/>
  `1 2 3;` → `1 2`

---

## 산술 연산 (Arithmetic Operations)

**`+`**

* **인자 개수:** 자동 형변환 (coerce)

* **숫자에 대해:** 덧셈 <br/>
  `5 7+` → `12`

* **문자열과 블록에 대해:** 이어붙이기 <br/>
  `'asdf'{1234}+` → `{asdf 1234}`

* **배열에 대해:** 연결 <br/>
  `[1 2 3][4 5]+` → `[1 2 3 4 5]`

---

**`-`**

* **인자 개수:** 자동 형변환 (coerce)

* **주의:** 첫 번째 예시처럼 `-`의 파싱 방식에 주의할 것 <br/>
  `1 2-3+` → `1 -1` <br/>
  `1 2 -3+` → `1 -1` <br/>
  `1 2- 3+` → `2`

* **배열에 대해:** 차집합 연산 (두 번째 배열에 포함된 요소 제거) <br/>
  `[5 2 5 4 1 1][1 2]-` → `[5 5 4]`

---

**`*`**

* **인자 개수:** order

* **정수에 대해:** 곱셈 <br/>
  `2 4*` → `8`

* **블록에 대해:** 지정된 횟수만큼 실행 (피연산자 순서 자동 정렬되므로 순서 무관) <br/>
  `2 {2*} 5*` → `64`

* **배열/문자열에 대해:** 반복 <br/>
  `[1 2 3]2*` → `[1 2 3 1 2 3]` <br/>
  `3'asdf'*` → `"asdfasdfasdf"`

* **배열과 구분자에 대해:** 조인 <br/>
  `[1 2 3]','*` → `"1,2,3"` <br/>
  `[1 2 3][4]*` → `[1 4 2 4 3]` <br/>
  `'asdf'' '*` → `"a s d f"` <br/>
  `[1 [2] [3 [4 [5]]]]'-'*` → `"1-\002-\003\004\005"` <br/>
  `[1 [2] [3 [4 [5]]]][6 7]*` → `[1 6 7 2 6 7 3 [4 [5]]]`

* **배열/문자열 + 블록에 대해:** 폴드(Fold) 연산 <br/>
  `[1 2 3 4]{+}*` → `10` <br/>
  `'asdf'{+}*` → `414`

---

**`/`**

* **인자 개수:** order

* **정수에 대해:** 나눗셈 (정수 나눗셈) <br/>
  `7 3 /` → `2`

* **배열 + 배열에 대해:** 두 번째 배열의 요소를 기준으로 첫 번째 배열 분할 <br/>
  `[1 2 3 4 2 3 5][2 3]/` → `[[1] [4] [5]]`

* **문자열 + 문자열에 대해:** 구분자 기준 분할 <br/>
  `'a s d f'' '/` → `["a" "s" "d" "f"]`

* **배열 + 정수에 대해:** 지정한 크기로 그룹화 <br/>
  `[1 2 3 4 5] 2/` → `[[1 2] [3 4] [5]]`

* **정수 + 블록 2개에 대해:** 언폴드(unfold), 일종의 while 루프. 조건 확인 전 스택 상단 값을 복제하고, 조건이 참일 경우 현재 상단 값을 결과 배열에 수집 <br/>
  `0 1 {100<} { .@+ } /` → `89 [1 1 2 3 5 8 13 21 34 55 89]`

* **배열 + 블록에 대해:** 각 요소에 대해 블록 실행 (Each) <br/>
  `[1 2 3]{1+}/` → `2 3 4`

---

**`%`**

* **인자 개수:** order

* **정수에 대해:** 나머지 연산 <br/>
  `7 3 %` → `1`

* **문자열 + 문자열에 대해:** `/`와 유사하나 빈 결과는 제거 <br/>
  `'assdfs' 's'%` → `["a" "df"]` <br/>
  `'assdfs' 's'/` → `["a" "" "df" ""]`

* **배열 + 정수에 대해:** 인덱스가 `0 mod n`인 요소 선택 (Python의 `[::n]`과 유사, 음수면 반대 순서로 선택) <br/>
  `[1 2 3 4 5] 2%` → `[1 3 5]` <br/>
  `[1 2 3 4 5] -1%` → `[5 4 3 2 1]`

* **배열 + 블록에 대해:** 매핑 (Map), 각 요소마다 블록을 실행한 결과들을 병합 <br/>
  `[1 2 3]{.}%` → `[1 1 2 2 3 3]`

---

**`?`**

* **인자 개수:** order

* **정수에 대해:** 거듭제곱 계산 <br/>
  `2 8?` → `256`

* **배열 + 요소에 대해:** 해당 요소의 인덱스를 반환, 없으면 `-1` <br/>
  `5 [4 3 5 1] ?` → `2`

* **배열 + 블록에 대해:** 블록을 만족하는 첫 번째 요소의 인덱스 반환 <br/>
  `[1 2 3 4 5 6] {.* 20>} ?` → `5`

---

**`(`**

* **인자 개수:** 1

* **정수에 대해:** 1 감소 <br/>
  `5(` → `4`

* **배열에 대해:** 왼쪽에서 Uncons (첫 요소 분리) <br/>
  `[1 2 3](` → `[2 3] 1`

---

**`)`**

* **인자 개수:** 1

* **정수에 대해:** 1 증가 <br/>
  `5)` → `6`

* **배열에 대해:** 오른쪽에서 Uncons (마지막 요소 분리) <br/>
  `[1 2 3])` → `[1 2] 3`

---

**`abs`**

* **인자 개수:** 1

* **설명:** 절댓값 계산 <br/>
  `-2 abs` → `2`

---

## 비트 연산 (Bitwise Operations)

**`~`**

* **인자 개수:** 1

* **정수에 대해:** 비트 반전 연산 <br/>
  `5~` → `-6`

* **문자열 및 블록에 대해:** 평가 <br/>
  `"1 2+"~` → `3` <br/>
  `{1 2+}~` → `3`

* **배열에 대해:** 요소 펼치기 (언팩) <br/>
  `[1 2 3]~` → `1 2 3`

---

**`|`**

* **인자 개수:** 자동 형변환 (coerce)

* **정수에 대해:** 비트 OR 연산 <br/>
  `5 3 |` → `7`

---

**`&`**

* **인자 개수:** 자동 형변환 (coerce)

* **배열에 대해:** 집합 AND 연산 (교집합) <br/>
  `[1 1 2 2][1 3]&` → `[1]`

---

**`^`**

* **인자 개수:** 자동 형변환 (coerce)

* **정수에 대해:** 비트 XOR 연산 <br/>

* **배열에 대해:** 대칭 차집합 (symmetric difference) <br/>
  `[1 1 2 2][1 3]^` → `[2 3]`

---

## 비교 연산 (Comparison Operations)

**`<`**

* **인자 개수:** order

* **같은 타입:** 작은지 비교. 참이면 `1`, 거짓이면 `0` <br/>
  `3 4 <` → `1` <br/>
  `"asdf" "asdg" <` → `1`

* **다른 타입:** 배열 또는 문자열에서 인덱스가 주어진 정수보다 작은 요소 선택 (Python의 `[:n]`과 유사) <br/>
  `[1 2 3] 2 <` → `[1 2]` <br/>
  `{asdf} -1 <` → `{asd}`

---

**`>`**

* **인자 개수:** order

* **같은 타입:** 큰지 비교. 참이면 `1`, 거짓이면 `0` <br/>
  `3 4 >` → `0` <br/>
  `"asdf" "asdg" >` → `0`

* **다른 타입:** 배열 또는 문자열에서 인덱스가 주어진 정수 이상인 요소 선택 (Python의 `[n:]`과 유사). 주의: 타입이 섞인 경우 동작이 달라질 수 있음 <br/>
  `[1 2 3] 2 >` → `[3]` <br/>
  `{asdf} -1 >` → `{f}`

---

**`=`**

* **인자 개수:** order

* **같은 타입:** 같은지 비교. 같으면 `1`, 다르면 `0` <br/>
  `3 4 =` → `0` <br/>
  `"asdf" "asdg" =` → `0`

* **다른 타입:** 배열 또는 문자열에서 주어진 인덱스의 요소 선택 (Python의 `[n]`과 유사). 인덱스가 범위를 벗어나면 아무것도 추가되지 않음 <br/>
  `[1 2 3] 2 =` → `3` <br/>
  `{asdf} -1 =` → `102`

---

**`!`**

* **인자 개수:** 1

* **동작:** `0`, 빈 배열(`[]`), 빈 문자열(`""`), 빈 블록(`{}`), `yield 1`은 `1`을 반환하고, 그 외의 값은 모두 `0`을 반환 <br/>
  `1!` → `0` <br/>
  `{asdf}!` → `0` <br/>
  `""!` → `1`

---

## 논리 연산 (Logical Operations)

**`and`, `or`, `xor`**

* **인자 개수:** 2

* **설명:** 지연 평가를 사용하는 불리언 연산. 다음과 같이 구현됨:
  `{1$if}:and;`
  `{1$\if}:or;`
  `{\!!{!}*}:xor;`

* **예시:**
  `5 {1 0/} or` → `5`
  `5 {1 1+} and` → `2`
  `0 [3] xor` → `[3]`
  `2 [3] xor` → `0`

---

## 배열/문자열 조작 (Array/String Manipulation)

**`,`**

* **인자 개수:** 1 또는 2

* **정수에 대해:** 0부터 n-1까지의 숫자로 이루어진 배열 생성 <br/>
  `10,` → `[0 1 2 3 4 5 6 7 8 9]`

* **배열에 대해:** 배열의 크기 반환 <br/>
  `10,,` → `10`

* **블록에 대해:** 두 번째 인자를 받아 map 수행, 결과가 참인 원소만 필터링 <br/>
  `10,{3%},` → `[1 2 4 5 7 8]`

---

**`zip`**

* **인자 개수:** 1

* **설명:** 배열의 행과 열을 전치(transpose) <br/>
  `[[1 2 3][4 5 6][7 8 9]]zip` → `[[1 4 7] [2 5 8] [3 6 9]]` <br/>
  `['asdf''1234']zip` → `["a1" "s2" "d3" "f4"]`

---

**`base`**

* **인자 개수:** 2

* **설명:** 부호 없는 진법 변환. 두 번째 인자는 기수(radix) <br/>
  `[1 1 0] 2 base` → `6` <br/>
  `6 2 base` → `[1 1 0]`

---

## 제어 구조 (Control Structures)

**`if`**

* **인자 개수:** 3

* **설명:** 조건 값을 팝하고, 참이면 첫 번째 블록 실행, 거짓이면 두 번째 블록 실행 <br/>
  `1 2 3 if` → `2` <br/>
  `0 2 {1.} if` → `1 1`

---

**`while`, `until`**

* **인자 개수:** 2

* **설명:** 조건 블록을 먼저 실행해 값 하나 팝, 그 값이 참(`while`) 또는 거짓(`until`)이면 본문 블록 실행 <br/>
  `5{.}{1-.}while` → `4 3 2 1 0 0` <br/>
  `5{.}{1-.}until` → `5`

---

**`do`**

* **인자 개수:** 1

* **설명:** `do...while` 루프. 블록을 실행하고 값 하나를 팝, 그 값이 참이면 반복 <br/>
  `5{1-..}do` → `4 3 2 1 0 0`

---

## 변수 및 할당 (Variables and Assignment)

**`:`**

* **인자 개수:** 1*

* **설명:** 스택 맨 위의 값을 `:` 뒤에 오는 변수에 할당. 문법에 내장된 기능이며, 내장 변수는 아님. 스택의 값을 소비하지 않음. <br/>
  `1:a a` → `1 1` <br/>
  `1:0;0` → `1`

---

## 입출력 (Input/Output)

**`print`**

* **인자 개수:** 1

* **설명:** 문자열로 변환한 뒤 출력

---

**`puts`**

* **인자 개수:** 1

* **설명:** 문자열로 변환하여 출력한 뒤 `n` 추가 (Ruby의 `puts`와 유사)
  `{print n print}:puts;` 으로 구현됨

---

**`p`**

* **인자 개수:** 1

* **설명:** 백틱(`)을 이용해 문자열로 변환 후 출력하고 `n`을 이어붙임 (Ruby의 `p`와 유사)  
  `{`puts}:p;` 로 구현됨

---

**`n`**

* **인자 개수:** 0

* **설명:** 줄바꿈 문자 (개행).
  `"\n":n;` 으로 구현됨

---

## 평가 및 문자열 변환 (Evaluation and String Conversion)

**`~`**

* **인자 개수:** 1

* **문자열 및 블록에 대해:** 평가 <br/>
  `"1 2+"~` → `3` <br/>
  `{1 2+}~` → `3`

* **배열에 대해:** 요소 펼치기 (언팩) <br/>
  `[1 2 3]~` → `1 2 3`

---

**`` ` ``**

* **인자 개수:** 1

* **`~`의 반대 연산:** 평가했을 때 원래 값을 복원하는 문자열 생성 <br/>
  `` 1` `` → `"1"`  
  `` [1 [2] 'asdf']` `` → `"[1 [2] \"asdf\"]"`  
  `` "1"` `` → `"\"1\""`  
  `` {1}` `` → `"{1}"`

---

## 리터럴 및 문법 (Literals and Syntax)

**`{ }`**

* **설명:** 블록 생성. 실제로는 내장 변수(built-in)가 아니라 문법의 일부임.

---

**`'`**

* **설명:** 원시 문자열. `\`와 `'`만 이스케이프 가능 <br/>
  `'\n'` → `"\\n"` <br/>
  `' \' '` → `" ' "`

---

**`"`**

* **설명:** 이스케이프 가능한 문자열 <br/>
  `"\n"` → 줄바꿈 문자 <br/>
  `"\144"` → `"d"`

---

**`[ ]`**

* **설명:** 의외일 수 있지만, `[ ]`는 문법에 내장된 것이 아님. 대신 `[`는 실행 시 스택 크기를 기록하고 `]`는 그 지점까지 스택을 잘라냄. 스택이 해당 지점보다 작아질 경우 `[` 위치가 자동으로 조정됨. 아래 예시에서는 결과가 `1 2 []`일 것 같지만, swap 중에 `1`과 `2`가 잠시 스택에서 빠지면서 `[`가 그 위치로 이동함. <br/>
  `1 2 [\]` → `[2 1]`

---

**`#`**

* **인자 개수:** 없음

* **설명:** 실제 내장 변수는 아니며, 줄바꿈까지의 모든 내용을 무시하는 주석 구문임

---

## 기타 유틸리티 (Miscellaneous Utilities)

**`rand`**

* **인자 개수:** 1

* **설명:** 0 이상 주어진 값 미만의 난수 정수 생성 <br/>
  `5 rand` → `2` (예시값)

---
  `6 2 base` → `[1 1 0]`
